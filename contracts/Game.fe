struct InvalidIndex:
    pass

struct NotMovable:
    pass

const EMPTY_FIELD_MARKER: u256 = 0
# We don't have dynamically sized arrays. Since the number of moves
# varies depending on the position of the empty field, we need a marker
# for invalid moves.

# We could turn this into a slightly cleaner value of -1 if we used signed integers
# That's blocked on https://github.com/ethereum/fe/issues/564
const INVALID_FIELD_MARKER: u256 = 666

contract Game:

    board: u256[16]
    moves: Map<u256, u256[4]>

    pub fn __init__(self, board: u256[16]):
        self.board = board
        # Map each empty slot to a list of possible moves
        # It would be nice to have fixed-size maps that work with `const` (baked into code)
        self.moves[0] = [1, 4, INVALID_FIELD_MARKER, INVALID_FIELD_MARKER]
        self.moves[1] = [0, 2, 5, INVALID_FIELD_MARKER]
        self.moves[2] = [1, 3, 6, INVALID_FIELD_MARKER]
        self.moves[3] = [2, 7, INVALID_FIELD_MARKER, INVALID_FIELD_MARKER]
        self.moves[4] = [0, 5, 8, INVALID_FIELD_MARKER]
        self.moves[5] = [1, 4, 6, 9]
        self.moves[6] = [2, 5, 7, 10]
        self.moves[7] = [3, 6, 11, INVALID_FIELD_MARKER]
        self.moves[8] = [4, 9, 12, INVALID_FIELD_MARKER]
        self.moves[9] = [5, 8, 10, 13]
        self.moves[10] = [6, 9, 11, 14]
        self.moves[11] = [7, 10, 15, INVALID_FIELD_MARKER]
        self.moves[12] = [8, 13, INVALID_FIELD_MARKER, INVALID_FIELD_MARKER]
        self.moves[13] = [9, 12, 14, INVALID_FIELD_MARKER]
        self.moves[14] = [10, 13, 15, INVALID_FIELD_MARKER]
        self.moves[15] = [11, 14, INVALID_FIELD_MARKER, INVALID_FIELD_MARKER]

    pub fn get_board(self) -> u256[16]:
        return self.board.to_mem()

    pub fn is_winning_state(self) -> bool:
        let index: u256 = 0
        let current_board: u256[16] = self.board.to_mem()
        # Workaround for: https://github.com/ethereum/fe/issues/528
        for _field in current_board:
            if current_board[index] != get_winning_state()[index]:
                return false
            index += 1

        return true

    pub fn move_field(self, index: u256):
        if not self.is_valid_index(index):
            revert InvalidIndex()
        else:
            let movable_fields: u256[4] = self.moves[self.get_index_of_empty_field()].to_mem()
            if not is_in(index, movable_fields):
                revert NotMovable()
            else:
                let empty_field_index: u256 = self.get_index_of_empty_field()
                let field_value: u256 = self.board[index]
                self.board[index] = EMPTY_FIELD_MARKER
                self.board[empty_field_index] = field_value

    fn get_index_of_empty_field(self) -> u256:
        let index: u256 = 0
        let current_board: u256[16] = self.board.to_mem()
        for field in current_board:
            if field == 0:
                break
            else:
                index += 1

        return index

    fn get_winning_state() -> u256[16]:
        # TODO: Make this a constant when complex constants are supported
        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

    fn is_valid_index(self, index: u256) -> bool:
        return index >= 0 and index <= 15

    fn is_in(num: u256, values: u256[4]) -> bool:
        for val in values:
            if val == num:
                return true
        return false


struct AlreadyLocked:
    pass

struct InvalidClaim:
    pass

struct OnlyAdmin:
    pass

struct ClaimLock:
    claimer: address
    valid_until_block: u256

const LOCK_PERIOD_IN_BLOCKS: u256 = 1000

contract BountyRegistry:

    lock: ClaimLock
    open_challenges: Map<address, bool>
    admin: address

    pub fn __init__(self, admin: address):
        self.admin = admin

    pub fn lock(self):
        if not self.is_locked():
            # Transfer WETH into this contract and revert if that fails
            self.lock = ClaimLock(claimer=msg.sender, valid_until_block=block.number+LOCK_PERIOD_IN_BLOCKS)
        else:
            revert AlreadyLocked()

    pub fn is_locked(self) -> bool:
        return self.lock.valid_until_block >= block.number

    pub fn register_challenge(self, challenge: address):
        if msg.sender != self.admin:
            revert OnlyAdmin()
        else:
            self.open_challenges[challenge] = true

    pub fn remove_challenge(self, challenge: address):
        if msg.sender != self.admin:
            revert OnlyAdmin()
        elif self.is_locked():
            revert AlreadyLocked()
        else:
            self.open_challenges[challenge] = false


    pub fn is_open_challenge(self, challenge: address) -> bool:
        return self.open_challenges[challenge]

    pub fn claim(self, challenge: address):
        if not self.is_locked():
            revert InvalidClaim()
        elif not self.open_challenges[challenge]:
            revert InvalidClaim()
        elif self.lock.claimer != msg.sender:
            revert InvalidClaim()
        else:
            let puzzle: Game = Game(challenge)
            if puzzle.is_winning_state():
                pass
                # TODO pay
            else:
                revert InvalidClaim()

    pub fn withdraw():
        # TODO: Admin should be allowed to withdraw funds if there's no lock in progress
        # This would be used to migrate to a new bounty registry
        pass