struct Unreachable:
    pass

struct InvalidIndex:
    pass

struct NotMovable:
    pass

const EMPTY_FIELD_MARKER: u256 = 0
# We don't have dynamically sized arrays. Since the number of moves
# varies depending on the position of the empty field, we need a marker
# for invalid moves.
const INVALID_FIELD_MARKER: u256 = 666

contract Game:

    board: u256[16]

    pub fn __init__(self, board: u256[16]):
        self.board = board

    pub fn get_board(self) -> u256[16]:
        return self.board.to_mem()

    pub fn is_winning_state(self) -> bool:
        let index: u256 = 0
        let current_board: u256[16] = self.board.to_mem()
        # Workaround for: https://github.com/ethereum/fe/issues/528
        for _field in current_board:
            if current_board[index] != get_winning_state()[index]:
                return false
            index += 1

        return true

    pub fn move_field(self, index: u256):
        if not self.is_valid_index(index):
            revert InvalidIndex()
        else:
            let movable_fields: u256[4] = self.get_moveable_fields()
            if not is_in(index, movable_fields):
                revert NotMovable()
            else:
                let empty_field_index: u256 = self.get_index_of_empty_field()
                let field_value: u256 = self.board[index]
                self.board[index] = EMPTY_FIELD_MARKER
                self.board[empty_field_index] = field_value

    fn get_index_of_empty_field(self) -> u256:
        let index: u256 = 0
        let current_board: u256[16] = self.board.to_mem()
        for field in current_board:
            if field == 0:
                break
            else:
                index += 1

        return index

    fn get_winning_state() -> u256[16]:
        # TODO: Make this a constant when complex constants are supported
        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

    fn is_valid_index(self, index: u256) -> bool:
        return index >= 0 and index <= 15

    fn is_in(num: u256, values: u256[4]) -> bool:
        for val in values:
            if val == num:
                return true
        return false

    fn get_moveable_fields (self) -> u256[4]:
        let empty_field_index: u256 = self.get_index_of_empty_field()

        # Meh: We needed to break this into two functions to not run into the infamous stack too deep error
        if empty_field_index == 0:
            return [1, 4, INVALID_FIELD_MARKER, INVALID_FIELD_MARKER]
        else:
            return self.get_more_moveable_fields()

    fn get_more_moveable_fields (self) -> u256[4]:
        let empty_field_index: u256 = self.get_index_of_empty_field()

        if empty_field_index == 1:
            return [0, 2, 5, INVALID_FIELD_MARKER]
        elif empty_field_index == 2 :
            return [1, 3, 6, INVALID_FIELD_MARKER]
        elif empty_field_index == 3 :
            return [2, 7, INVALID_FIELD_MARKER, INVALID_FIELD_MARKER]
        elif empty_field_index == 4 :
            return [0, 5, 8, INVALID_FIELD_MARKER]
        elif empty_field_index == 5 :
            return [1, 4, 6, 9]
        elif empty_field_index == 6 :
            return [2, 5, 7, 10]
        elif empty_field_index == 7 :
            return [3, 6, 11, INVALID_FIELD_MARKER]
        elif empty_field_index == 8 :
            return [4, 9, 12, INVALID_FIELD_MARKER]
        elif empty_field_index == 9 :
            return [5, 8, 10, 13]
        elif empty_field_index == 10:
            return [6, 9, 11, 14]
        elif empty_field_index == 11:
            return [7, 10, 15, INVALID_FIELD_MARKER]
        elif empty_field_index == 12:
            return [8, 13, INVALID_FIELD_MARKER, INVALID_FIELD_MARKER]
        elif empty_field_index == 13:
            return [9, 12, 14, INVALID_FIELD_MARKER]
        elif empty_field_index == 14:
            return [10, 13, 15, INVALID_FIELD_MARKER]
        elif empty_field_index == 15:
            return [11, 14, INVALID_FIELD_MARKER, INVALID_FIELD_MARKER]

        revert Unreachable()